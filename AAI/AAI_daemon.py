#!/usr/bin/env python2.7
__author__ = "stthomse@cisco.com"
__copyright__ = "2016,2017 Cisco Systems, Inc"

"""
AAI Monitor, Python 2.7.

This tool scrapes status file generated by ARTIM_AutoIngestion.py
The lines expected in status file is:
    Daemon started
    Get Config File
    Got Config File
    Temp Location Readied
    Parse config file
    Checking validity of config data
    Config data is valid
    Copy image to temp location
    Mounting image
    Ingestion started
    Ingestion done
    Cleanup
    Stop

Script ASSUMES:
1. Script is run from /opt/virtuata/endpoint/bin. All paths are relatively set.
2. zlog has been enabled and built into AAI (makefile).
3. IPMITOOL and IPMI driver are running on the Host (ubuntu 14.04 includes
IPMI driver. IPMITOOL has to be installed. This can be part of the standard
AAI Host Ubuntu image.
4. Our custom McTools ID is recognized by the McTools parser so that our
messages get displayed in UCSM.

IMPORTANT: We can send only one SEL message at a time!

Process flow is:
0. take in command line input
1. find the AAI log file
2. capture the latest timestamp in logfile
3. parse log file for certain strings and take only those newer than timestamp
4. copy the informational strings to a buffer file and save
5. parse the buffer file and covert each string into a enumerated value
6. construct the IPMI OEM SEL message with the enumerated message in the errcode
7. send the IPMI OEM SEL command via cmd line call using IPMITOOL
8. delay as configured (e.g. 1 sec)
9. start over again at step 2

"""

import time
from daemon import runner
import logging
import traceback
import os
import os.path
import sys
import subprocess
import getopt
import re
import argparse as ap
import uuid
import shlex
import time
import csv
import datetime as dt
import heartbeat
import paho.mqtt.client as mqtt

is_verbose = False
global debug
debug = False
global new_lasttime     # Use this everywhere.
localDebug = True
heartbeatFileName = "/var/log/AAIdaemon/AAIdaemon.log"
statusFileName = "/home/ARTIM/DashBoard/AAIdaemon.log"
global maxStatusLine
maxStatusLine = 1
global sleepTime
sleepTime = 1

# Function for debug printing
def debugPrint(message):
    if debug:
        print (message)

# Function for publishing with MQTT
def publishMessage(message):
    mqttc = mqtt.Client("python_pub")
    mqttc.connect("localhost", 1883)
    mqttc.publish("AAI", message)
    mqttc.loop(2) # timeout = 2s

# *IMPORTANT REMINDER* Setup: you must create the folders for the pid and
# the log. 

class App():
    def __init__(self):
        self.stdin_path = '/dev/null'
#        self.stdout_path = '/dev/tty'
        self.stdout_path = '/dev/null'
#        self.stderr_path = '/dev/tty'
        self.stderr_path = '/dev/null'
        self.pidfile_path =  '/var/run/AAIdaemon/AAIdaemon.pid'
        self.pidfile_timeout = 5
        self.delay = 30
#        self.ParseFile = '/media/import/logs.25marlast.small'
        self.ParseFile = '/opt/virtuata/endpoint/bin/logs'
        self.msg_buffer =[]

    def run(self):
        logger.debug ("Starting the monitor...")
        self.mon_preamble()
        logger.debug ("Returned from mon_preamble.")
        time.sleep(self.delay)
        while True:
            self.mon_file_parse(self.ParseFile)
            self.mon_sel(msg_buffer)
            logger.debug("Returned from \'mon_sel\'.") 
            
            logger.info("Brief Sleep...") 
            time.sleep(self.delay)

    def mon_preamble(self):
        global delay
        global ParseFile
        global first_lasttime
        global new_lasttime

        logger.debug ("Entering \'mon_preamble\'")
        
        #
        # Print banner to output indicating the program info.
        #
        logger.info ('***  Cisco/CSPG/stthomse, AAI_daemon.py')
        logger.info ('***  AAI output and send to UCSM SEL.')

        #
        #  Create our parser using argparse utility.
        #
        ''' Need to move these to the daemon cmd line parms.
        parser = ap.ArgumentParser(description='Process inputs.')

        parser.add_argument('ParseDelay', help='Enter a number for the parse period \
                            (seconds) that the Monitor shall use.', type = int)

        parser.add_argument('ParseFile', help='Enter the name of the log file to parse.')

        # Now grab the command line data and buffer it.
        data = parser.parse_args()
        delay = data.ParseDelay
        ParseFile = data.ParseFile
        if debug:
            print ("DEBUG: Delay passed in:", delay)
        '''

        #
        # Before going futher, confirm that the IPMITOOL is there.
        #
        logger.info ("Testing whether IPMITool responds...")
        rt = subprocess.call(['ipmitool', '-I', 'open', 'channel', 'info'])
        if rt != 0:
            logger.info ('IPMITOOL failed. Exiting.')
            exit(1)
        else:
            logger.info ("IPMI Tool passed.")

        # Set up the initial timestamp to 0.
        # first_lasttime = '2000-01-01 00:00:00.000'
        # first_lasttime = dt.datetime.strptime(first_lasttime, "%Y-%m-%d %H:%M:%S.%f")
		# Set up initial time to be the current time, else stale messages will be present
        first_lasttime = dt.datetime.now()
        logger.info ("DEBUG: First lasttime:%s", first_lasttime)
        new_lasttime = first_lasttime
        logger.debug ("End of \'mon_preamble\'")
#        return self.delay, self.ParseFile
        return self.ParseFile

    def mon_file_parse(self, ParseFile):
        global msg_buffer
        global new_lasttime # We are using/updating this Global locally. 
        
        #
        # Parse the file looking for our important strings.
        #
        # Since we periodically parse the same, albeit growing log file, we risk
        # re-encountering the same entries, grepping them out, and sending them all
        # over again. Not OK.
        # Solution: capture latest timestamp from end of the log file and save that
        # locally for next time though. Start this out by setting initial date to
        # some date in the past. Then, when we add to local buffer file, with
        # timestamps from the log, we will simply go to the last timestamp and
        # start parsing from there for my fresh IPMI messages.
        # Here are some samples to grep for, with my type enumeration added:
        #  type 0: 2016-03-25 14:00:31.716 VBND INFO -- Virtuata protection enabled --
        #  type 1: 2016-03-25 14:00:31.827 VBND DEBUG Dom 54 has finished booting
        #  type 2: 2016-03-25 14:00:31.830 IDEN DEBUG WARNING: No match found found. UNAUTHORIZED!
        #  type 3: ...

        logger.debug ("Entering \'mon_file_parse\'")

        # Note that once this function finishes the file is closed!
        lasttime = 0
        msg_buffer = []
        # Add target strings to this list. 
        match_list = ['Virtuata protection enabled', 'has finished booting', 'No match found']

        # Check for the log file existence
        # The daemon exits if the log file is not present.So we wait until the
        # AAI log file is generated
        isFile = os.path.exists("/opt/virtuata/endpoint/bin/logs")
        while (isFile == False):
            isFile = os.path.exists("/opt/virtuata/endpoint/bin/logs")
            logger.info ("Waiting for AAI log file")

        with open(ParseFile, 'r') as f:
            for line_num, line in enumerate(f):
                lastline = line 
                if any(x in line for x in match_list):
                    logger.info ('** Hit in row:', line)
                    msg_buffer.append(line)

        #
        # Clear out the old messages from msg buffer.
        # Do this by checking timestamps against the lasttime taken previously.
        # *WARNING: timestamp math*
        if debug:
            logger.debug ("DEBUG: message buffer contains:", msg_buffer, "\n")
            logger.debug ("DEBUG: length of message buffer:", len(msg_buffer), "\n")

        # BUGBUG: we are missing lines in the msg_buffer when we get here.
        # We are somehow skipping some lines; 1, 2, 3, 6
        for num, line in enumerate(msg_buffer):
            msg_buffer = list(msg_buffer)  # IMPORTANT: refresh, we've already iterated over it once!
            line_time = ' '.join(line.split()[0:2])
            if debug:
                logger.debug ("DEBUG: For line number {} line time is {}\n".format(num, line_time))
            new_time = dt.datetime.strptime(line_time, "%Y-%m-%d %H:%M:%S.%f")
            if debug:
                logger.debug ('DEBUG: New time:', new_time, '\n', 'last time:', new_lasttime)
            d = new_time - new_lasttime
            if debug:
                logger.debug ('DEBUG: Timedelta', d)
            if d.days < 0:
                logger.debug ('DEBUG: Stale line in msg buffer. Removing:', line)
                msg_buffer.remove(line)

        #
        # Get latest date:time - will be on the last line of the file at any given time.            
        # format: 2016-03-25 14:00:31.830
        #
        if debug:
            logger.debug ("\nDEBUG: Update message buffer contains:")
            for message in msg_buffer:
                logger.info (message)
            logger.debug ("DEBUG: Found last line:%s\n", lastline)

        new_lasttime = ' '.join(lastline.split()[0:2])
        new_lasttime = dt.datetime.strptime(new_lasttime, "%Y-%m-%d %H:%M:%S.%f")
        if debug:
            logger.debug ("DEBUG: Updated lasttime:%s", new_lasttime, "\n")

        #
        # Place filtered info into my buffer file.
        # This buffer file gets updated completely each time we scrape the logs.
        with open('AAI_MonBuffFile.log', 'w') as f:
            s = str(msg_buffer)
            f.write(s)
            f.close
        logger.debug ("Exiting \'mon_file_parse\'")
        return self.msg_buffer

    def mon_sel(self, msg_buffer):
        #
        # Parse the buffer file and convert to enum types.
        #
        #  0  "AAI_LAUNCHED",
        #  1  "AAI_DOM_FINISHED_BOOTING",
        #  2  "AAI_NO_MATCH_UNAUTHORIZED",
        #  3  "AAI_PAGE_AUTHORIZED",
        #  4  "AAI_PROCESS_REMEDIATED",
        #  5  "AAI_PROCESS_KILLED"
        #
        # IMPORTANT: since our polling is relatively rare, there may be multiple events
        # to send to SEL. Therefore, we need a way to cache multiple events, parse them,
        # and then flush that queue. 

        logger.debug ("Entering \'mon_sel\'")

        msg_enum = []
        for line in msg_buffer:
            if "Virtuata protection enabled" in line:
                msg_enum.append(0)
                if debug:
                    print ("Message Enum Hit! Append 0")
            if "has finished booting" in line:
                msg_enum.append(1)
                if debug:
                    print ("Message Enum Hit! Append 1")
            if "No match found" in line:
                msg_enum.append(2)
                if debug:
                    print ("Message Enum Hit! Append 2")
            if "authorized" in line:
                msg_enum.append(3)
                if debug:
                    print ("Message Enum Hit! Append 3")
            if "remediated" in line:
                msg_enum.append(4)
                if debug:
                    print ("Message Enum Hit! Append 4")
            if "killed" in line:
                msg_enum.append(5)

        if debug:
            print ("message enumeration: %s\n", msg_enum)

        # Create OEM SEL:
        # IPMITOOL raw 0x0a 0x00 0xdf <buffer message>
        #  Commands:
        #        raw           Send a RAW IPMI request and print response
        #           means that we will build the command from raw bytes, as in an OEM command, e.g.
        # We'll use IPMI OEM SEL type 0xDF since that is open.
        # But there is no decoder in UCSM so messages will suck. Oh well.
        #  ipmitool raw 0x0a 0x44 0x01 0x00 0xdf 0x00 0x11 0x22 0x33 0x0A 0x55 0x0a 0x00
        #  0x00 0x00 0x00 0x00 0x01

        # CAUTION: Formatting here is crucial! 
        ipmi_oem_sel_preamble = 'ipmitool ' + 'raw ' + '0x0a ' + '0x44 ' + '0x01 ' + '0x00 ' + '0xdf ' + \
                               '0x00 ' + '0x11 ' + '0x22 ' + '0x33 ' + '0xaa ' + '0x55 ' + '0xaa ' + '0x0'

        ipmi_oem_sel_postamble = ' 0x00 ' + '0x00 ' + '0x00 ' + '0x00 ' +  '0x22 '

        #
        # Now parse the msg_enum taking one off at a time, from first to last.
        # find out how long: len(msg_enum)
        if debug:
            print ("DEBUG: msg_enum", len(msg_enum))
        msg_len = len(msg_enum)
        msg_index = 0
        while (msg_index < msg_len):
            if debug:
                print ("DEBUG: msg_enum entry {} is {}".format(msg_index, msg_enum[msg_index]))
            ipmi_oem_sel_message = ipmi_oem_sel_preamble + str(msg_enum[msg_index]) + ipmi_oem_sel_postamble
            if debug:
                print ("DEBUG: ", ipmi_oem_sel_message)
            args = shlex.split(ipmi_oem_sel_message)
            logger.info ("Sending IPMI SEL message to UCSM.")
            rt = subprocess.Popen(args)
            time.sleep(0.5)
            if rt == 0:
                print ('IPMITOOL failed. Exiting AAI Monitor.\n')
                exit(1)
            msg_index += 1
        logger.debug ("Exiting \'mon_sel\'")

def writeStatusFile(myString):
    global maxStatusLine
    debugPrint('writeStatusFile:')
    debugPrint('\tmyString = "' + myString +'"')
    debugPrint('\tLength = ' + str(len(myString)))
    debugPrint('\tmaxStatusLine = ' + str(maxStatusLine))
    try: 
        statusFile = open(statusFileName, 'w', 0) # to write now
    except:
        print('Error opening status file(' + statusFileName + ')')
        heartbeatFile.close()
        exit(23)
    printString = myString
    if len(myString) > maxStatusLine:
        maxStatusLine = len(myString)
    else:
        addSpaces = maxStatusLine - len(myString)
        debugPrint('writeStatusFile: need to add ' + str(addSpaces)
                   + ' spaces')
        debugPrint('writeStatusFile: len is ' + str(len(printString)))
        i = 0
        while i < addSpaces:
            printString += ' '
            debugPrint('writeStatusFile: adding space len is '
                       + str(len(printString)))
            i = i + 1
    printString += '\n'
    try:
        debugPrint(printString)
        statusFile.write(printString)
    except:
        print('Error writing status file(' + statusFileName + ')')
        heartbeatFile.close()
        statusFile.close()
        exit(24)
    statusFile.flush()
    statusFile.close()

debugPrintLine = False
class DaemonApp(object):  
    """Daemon App."""

    def __init__(self):
        """Initialize Daemon."""
        if localDebug:
            self.stdin_path = '/dev/tty'
            self.stdout_path = '/dev/tty'
            self.stderr_path = '/dev/tty'
        else:
            self.stdin_path = '/dev/null'
            self.stdout_path = '/dev/null'
            self.stderr_path = '/dev/null'
        self.pidfile_path = '/tmp/daemon.pid'
        self.pidfile_timeout = 1

    def run(self):
        """Main Daemon Code."""
        global heartbeatFileName
        copyStarted = False
        ingestionStarted = False
        count = 1
        while True:
            time.sleep(sleepTime)
            totalSleep = count * 5
            # Check file for action
            try:
                heartbeatFile = open(heartbeatFileName, 'r')
            except:
                print('Error opening heartbeat file(' + heartbeatFileName + ')')
                exit(21)
            try:
                longLine = heartbeatFile.read()
                line = longLine.rstrip('\n')
                if debugPrintLine:
                    debugPrint('Read line: "' + line + '"')
            except:
                print('Failed to read line')
                heartbeatFile.close()
                exit(22)
            if line == 'Daemon started':
                publishMessage(line)
            elif line == 'Get Config File':
                publishMessage(line)
            elif line == 'Got Config File':
                publishMessage(line)
            elif line == 'Temp Location Readied':
                publishMessage(line)
            elif line == 'Parse config file':
                publishMessage(line)
            elif line == 'Checking validity of config data':
                publishMessage(line)
            elif line == 'Config data is valid':
                publishMessage(line)
            elif line == 'Copy image to temp location':
                if not copyStarted:
                    copyStarted = True
                    count = 1
                    debugPrint('Daemon found "Copy image to temp location"')
                totalSleep = count * sleepTime
                publishMessage(line + ' ' + str(totalSleep))
            elif line == 'Mounting image':
                copyStarted = False
                publishMessage(line)
            elif line == 'Ingestion started':
                if not ingestionStarted:
                    ingestionStarted = True
                    count = 1
                    debugPrint('Daemon found "Ingestion started"')
                totalSleep = count * sleepTime
                publishMessage(line + ' ' + str(totalSleep))
            elif line == 'Ingestion done':
                ingestionStarted = False
                publishMessage(line)
            elif line == 'Cleanup':
                publishMessage(line)
            elif line == 'Stop':
                publishMessage(line)
                heartbeatFile.close()
                exit(0)
            else:
                debugPrint('Daemon found unknown: "' + line + '"')
            count = count + 1

# This code is for debugging local version only
if localDebug:
    print('Doing local debug')
    app = DaemonApp()
    daemon_runner = runner.DaemonRunner(app)
    daemon_runner.do_action()
    debugPrint('Daemon is ready to die')
    exit(0)

app = App()
# Set up logger.
logger = logging.getLogger("AAIDaemonLog")
# This sets the level of logging, with DEBUG being lowest.
logger.setLevel(logging.INFO)
#logger.setLevel(logging.DEBUG)
formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
handler = logging.FileHandler(heartbeatFileName)
handler.setFormatter(formatter)
logger.addHandler(handler)

# Time to daemon it
debugPrint('Logging all set, time for daemon Runner')
daemon_runner = runner.DaemonRunner(app)
daemon_runner.daemon_context.files_preserve=[handler.stream]
daemon_runner.do_action()
